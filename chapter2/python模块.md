## python模块　包

一个文件被看作是一个独立模块, 一个模块也可以被看作是一个文件。



### 1. 名称空间

所以每个模块都定义了它自
己的唯一的名称空间。 如果我在我自己的模块 mymodule 里创建了一个 atoi() 函数, 那么它的名
字应该是 mymodule.atoi() 。 所以即使属性之间有名称冲突, 但它们的完整授权名称(fully
qualified name)——通过句点属性标识指定了各自的名称空间 - 防止了名称冲突的发生。



* 执行期间有两个或三个活动的名称空间。 这三个名称空间分别是局部名称空间, 全局名称空间和内建名称空间
* Python 解释器首先加载内建名称空间。 它由`__builtins__`  模块中的名字构成。 随后加载执行模块的全局名称空间, 它会在模块开始执行后变为活动名称空间。



### 2. 模块搜索路径

默认搜索路径是在编译或是安装时指定的。 一个是启动 Python 的 shell 或命令行的 PYTHONPATH 环境变量。 该变量的内容是一组用冒号分割的目录路径。 如果你想让解释器使用这个变量, 那么请确保在启动解释器或执行 Python 脚本前设置或修改了该变量。
解释器启动之后, 也可以访问这个搜索路径, 它会被保存在 sys 模块的 sys.path 变量里。
不过它已经不是冒号分割的字符串, 而是包含每个独立路径的列表。我们可以在python的代码中随地对它进行修改。

设置路径的方式：

* 设置环境变量PYTHONPATH
* 在代码中修改sys.path变量



### 3. 导入模块

```
import xxx
form 模块名 import 属性名
import Tkinter as tk
from cgi import FieldStorage as form
```

* 加载模块会导致这个模块被"执行"。 也就是被导入模块的顶层代码将直接被执行。当然, 这样的执行可能不是我们想要的结果。 你应该把尽可能多的代码封装到函数。
* 一个模块只被加载一次, 无论它被导入多少次。
* `__name__`直接执行当前模块时该值是`__main__`,如果是导入则是对应的模块名
* 调用 from-import 可以把名字导入当前的名称空间里去, 这意味着你不需要使用属性/句点
  属性标识来访问模块的标识符。但是我们认为 "from module import *" 不是良好的编程风格, 因为它"污染"当前名称空间
* globals() 和 locals() 内建函数分别返回调用者全局和局部名称空间的字典。
* reload() 内建函数可以重新导入一个已经导入的模块。
* 当 Python 解释器在标准模式下启动时, 一些模块会被解释器自动导入, 用于系统相关操作
* sys.modules 变量包含一个由当前载入(完整且成功导入)到解释器的模块组成的字典
* 如果你不想让某个模块属性被 "from module import *" 导入 , 那么你可以给你不想导入的属
  性名称加上一个下划线( _ )。
* 注意不要出现[导入循环](https://blog.csdn.net/u010318270/article/details/71171228)问题


### 4. 包

[Python中包](https://www.cnblogs.com/yinzhengjie/p/8587656.html)

* 包是一个有层次的文件目录结构, 它定义了一个由模块和子包组成的 Python 应用程序执行环境。
* 判断目录下是否有`__init__.py`这个文件就好了，如果有那么就是Python Package包，如果没有，就是个普通的目录
* `__init__.py` 中加入`__all__`  变量. 该变量包含执行这样的语句时应该导入的模块的名字.

#### 5. pyc文件

pyc文件是py文件编译后生成的字节码文件(byte code)。pyc文件经过python解释器最终会生成机器码运行。所以pyc文件是可以跨平台部署的，类似Java的.class文件。一般py文件改变后，都会重新生成pyc文件。

[Python生成pyc文件](https://www.cnblogs.com/zhangqunshi/p/6657208.html)